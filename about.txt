первые шаги работы с плагинами вебпака.

установим плагин для взаимодействия с html
npm i -D html-webpack-plugin

добавляем его в конфиг, импортируя пакет
const HTMLWebpackPlugin = require('html-webpack-plugin');

и добавляем в массив плагинов (каждый плагин - это экземпляр класса)

plugins: [
  new HTMLWebpackPlugin()
]

перед запуском сборки сохраним html файл в папке src, чтобы не потерять его, иначе вебпак перезапишет этот файл в папке dist

если теперь запустить сборку, то на выходе получим, кроме js-файлов, сгенерированный плагином
пустой html с подключенными скриптами. Чтобы изменить title документа, передадим его как опцию в конструктор класса
new HTMLWebpackPlugin({
  title: 'Webpack course'
})

появилась новая проблема, контент добавленный в html теперь не доступен в сгенерированном html файле.

теперь в index.html, который лежит в src, удаляем подключение предыдущих скриптов, подключение осуществит установленный плагин

чтобы сохранить контент в html файле добавим путь до этого файла в опции плагина
new HTMLWebpackPlugin({
  title: 'Webpack course',
  template: './src/index.html'
})
при очередной сборке конечный html файл будет содержать подключенные скрипты и тот контент, который был прописан в исходном
при этом title берется из шаблона, а не из опций плагина, поэтому эту опцию можно удалить

на этом этапе так же решим проблему очистки папки dist от предыдущих бандлов
установим новый плагин
npm i -D clean-webpack-plugin

импортируем установленный плагин
const {CleanWebpackPlugin} = require('clean-webpack-plugin');

добавляем экземпляр класса в массив плагинов

протестируем, изменив что-нибудь в одном из скрипте и пересобрав бандлы

для более удобной работы с вебпак, модифицируем скрипты в package.json
"scripts": {
  "dev": "webpack --mode development", не минифицированные файлы
  "build": "webpack --mode production" минифицированные файлы
},

теперь у нас есть два скрипта - сборка для разработки и для продакшена

